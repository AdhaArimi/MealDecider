/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./fallbackMeals.js":
/*!**************************!*\
  !*** ./fallbackMeals.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   fallbackMeals: () => (/* binding */ fallbackMeals)\n/* harmony export */ });\nconst fallbackMeals = {\n    \"Healthy\": [\n        \"Greek Salad ü•ó\", \"Quinoa Bowl ü•ó\", \"Grilled Chicken Salad ü•ó\",\n        \"Avocado Toast ü•ë\", \"Smoothie Bowl üçì\", \"Lentil Soup üç≤\",\n        \"Zucchini Noodles üçù\", \"Stuffed Bell Peppers üå∂Ô∏è\", \"Chickpea Salad ü•ó\",\n        \"Kale Caesar Salad ü•ó\", \"Roasted Veggie Wrap üåØ\", \"Spinach and Feta Omelette üç≥\",\n        \"Berry Parfait üçì\", \"Miso Soup üç≤\", \"Edamame Beans ü•¢\"\n    ],\n    \"Fast\": [\n        \"Cheeseburger üçî\", \"Pizza üçï\", \"Hot Dog üå≠\",\n        \"Chicken Nuggets üçó\", \"Fries üçü\", \"Fish and Chips üêü\",\n        \"Taco üåÆ\", \"Burrito üåØ\", \"Quesadilla ü´î\",\n        \"Onion Rings üßÖ\", \"Corn Dog üå≠\", \"Sloppy Joe üçî\",\n        \"Chicken Wings üçó\", \"Mozzarella Sticks üßÄ\", \"Loaded Nachos üßÄ\"\n    ],\n    \"Asian\": [\n        \"Sushi Roll üç±\", \"Pad Thai üçú\", \"Fried Rice üçö\",\n        \"Ramen üçú\", \"Dim Sum ü•ü\", \"Spring Rolls ü•¢\",\n        \"Teriyaki Chicken üçó\", \"Pho üç≤\", \"Curry üçõ\",\n        \"Kimchi Stew üç≤\", \"Bibimbap üç≤\", \"Sashimi üç£\",\n        \"Peking Duck ü¶Ü\", \"Tom Yum Soup üç≤\", \"Satay Skewers üç¢\"\n    ],\n    \"Italian\": [\n        \"Spaghetti üçù\", \"Margherita Pizza üçï\", \"Lasagna üçù\",\n        \"Risotto üçö\", \"Fettuccine Alfredo üçù\", \"Bruschetta üçÖ\",\n        \"Caprese Salad ü•ó\", \"Tiramisu üç∞\", \"Gelato üç¶\",\n        \"Gnocchi üçù\", \"Pesto Pasta üçù\", \"Minestrone Soup üç≤\",\n        \"Osso Buco üçñ\", \"Cannoli üç∞\", \"Panettone üçû\"\n    ],\n    \"Mexican\": [\n        \"Tacos üåÆ\", \"Burrito üåØ\", \"Quesadilla ü´î\",\n        \"Enchiladas üåØ\", \"Guacamole ü•ë\", \"Churros üç©\",\n        \"Nachos üßÄ\", \"Tamales üåΩ\", \"Fajitas üå∂Ô∏è\",\n        \"Pozole üç≤\", \"Tostadas üåÆ\", \"Sopes üåÆ\",\n        \"Mole Poblano üçõ\", \"Flan üçÆ\", \"Horchata üçπ\"\n    ],\n    \"Dessert\": [\n        \"Chocolate Cake üç∞\", \"Ice Cream üç®\", \"Apple Pie ü•ß\",\n        \"Brownies üç´\", \"Cheesecake üç∞\", \"Panna Cotta üçÆ\",\n        \"Macarons üç¨\", \"Cupcakes üßÅ\", \"Pavlova üçì\",\n        \"Tiramisu üç∞\", \"Creme Brulee üçÆ\", \"Eclairs üç´\",\n        \"Baklava üçØ\", \"Mousse üç´\", \"Trifle üç∞\"\n    ],\n    \"Breakfast\": [\n        \"Pancakes ü•û\", \"Omelette üç≥\", \"French Toast üçû\",\n        \"Bagel with Cream Cheese ü•Ø\", \"Breakfast Burrito üåØ\", \"Granola with Yogurt ü•£\",\n        \"Eggs Benedict üç≥\", \"Smoothie üçπ\", \"Waffles üßá\",\n        \"Avocado Toast ü•ë\", \"Breakfast Sandwich ü•™\", \"Muffins üßÅ\",\n        \"Cereal with Milk ü•£\", \"Hash Browns ü•î\", \"Quiche üç≥\"\n    ],\n    \"Vegetarian\": [\n        \"Veggie Burger ü•¨\", \"Falafel üßÜ\", \"Buddha Bowl ü•ó\",\n        \"Vegetable Stir Fry üç≤\", \"Stuffed Mushrooms üçÑ\", \"Vegetable Curry üçõ\",\n        \"Tofu Scramble üç≥\", \"Vegetable Paella üçö\", \"Ratatouille üçÜ\",\n        \"Caprese Sandwich ü•™\", \"Lentil Stew üç≤\", \"Eggplant Parmesan üçÜ\",\n        \"Stuffed Peppers üå∂Ô∏è\", \"Vegetable Lasagna üçù\", \"Chickpea Salad ü•ó\"\n    ],\n    \"Seafood\": [\n        \"Grilled Salmon üêü\", \"Shrimp Scampi ü¶ê\", \"Fish Tacos üê†\",\n        \"Lobster Roll ü¶û\", \"Crab Cakes ü¶Ä\", \"Paella with Seafood üçö\",\n        \"Oysters ü¶™\", \"Ceviche üç§\", \"Clam Chowder üç≤\",\n        \"Mussels in White Wine Sauce ü¶™\", \"Sushi üç£\", \"Calamari ü¶ë\",\n        \"Tuna Tartare üç£\", \"Bouillabaisse üç≤\", \"Fish and Chips üêü\"\n    ],\n    \"Comfort\": [\n        \"Mac and Cheese üßÄ\", \"Chicken Soup üç≤\", \"Meatloaf üçñ\",\n        \"Shepherd's Pie ü•ß\", \"Pot Roast üçñ\", \"Chili Con Carne üå∂Ô∏è\",\n        \"Mashed Potatoes ü•î\", \"Beef Stew üç≤\", \"Chicken Pot Pie ü•ß\",\n        \"Baked Ziti üçù\", \"Cornbread üçû\", \"Fried Chicken üçó\",\n        \"Biscuits and Gravy üçû\", \"Pork Chops üçñ\", \"Stuffed Cabbage Rolls üåØ\"\n    ]\n}; \n\n//# sourceURL=webpack:///./fallbackMeals.js?");

/***/ }),

/***/ "./script.js":
/*!*******************!*\
  !*** ./script.js ***!
  \*******************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _fallbackMeals_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fallbackMeals.js */ \"./fallbackMeals.js\");\nconsole.log(\"script.js is running\");\n// Import the fallback meals\n\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    const HF_ACCESS_TOKEN = \"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\";\n\n    let currentMeal = '';\n    let currentCategory = '';\n    const categorySelect = document.getElementById('categorySelect');\n    const decideMealBtn = document.getElementById('decideMealBtn');\n    const mealResult = document.getElementById('mealResult');\n    const uploadSection = document.getElementById('uploadSection');\n    const uploadForm = document.getElementById('uploadForm');\n    const imagePreview = document.getElementById('imagePreview');\n    const uploadFeedback = document.getElementById('uploadFeedback');\n\n    // Enable/disable button based on category selection\n    categorySelect.addEventListener('change', function() {\n        decideMealBtn.disabled = !this.value;\n        if (this.value) {\n            currentCategory = this.value;\n        }\n    });\n\n    async function getMealSuggestion(category, maxRetries = 3) {\n        let retries = 0;\n        decideMealBtn.disabled = true;\n        mealResult.innerHTML = '<div class=\"spinner-border text-primary\" role=\"status\"><span class=\"visually-hidden\">Loading...</span></div>';\n        \n        while (retries < maxRetries) {\n            try {\n                const prompt = `Name a popular ${category} dish. Output format: [dish name]`;\n                console.log('Meal Suggestion Prompt:', prompt);\n\n                const response = await fetch(\n                    \"https://api-inference.huggingface.co/models/facebook/bart-large\",\n                    {\n                        headers: {\n                            \"Authorization\": `Bearer ${HF_ACCESS_TOKEN}`,\n                            \"Content-Type\": \"application/json\"\n                        },\n                        method: \"POST\",\n                        body: JSON.stringify({\n                            inputs: prompt,\n                            parameters: {\n                                max_length: 20,\n                                min_length: 2,\n                                temperature: 0.7,\n                                top_p: 0.95,\n                                do_sample: true,\n                                return_full_text: false\n                            }\n                        })\n                    }\n                );\n\n                const result = await response.json();\n                console.log('Raw Response:', result);\n                \n                if (result.error) {\n                    if (result.error.includes('loading')) {\n                        retries++;\n                        console.log(`Model loading, attempt ${retries} of ${maxRetries}...`);\n                        await new Promise(resolve => setTimeout(resolve, 2000));\n                        continue;\n                    }\n                    throw new Error(result.error);\n                }\n\n                // Clean BART's output\n                let suggestion = Array.isArray(result) ? result[0].generated_text : result.generated_text;\n                suggestion = suggestion\n                    .trim()\n                    .split('\\n')[0]\n                    .replace(/[\\[\\]]/g, '')  // Remove brackets\n                    .replace(/[\"\"\"]/g, '')\n                    .replace(/^[^a-zA-Z]+/, '')\n                    .replace(/^(name|a popular|dish|suggest|try|how about|you should try|i recommend|one)\\s*/i, '')\n                    .trim();\n\n                console.log('Cleaned Suggestion:', suggestion);\n\n                if (!suggestion) {\n                    throw new Error('Empty response from model');\n                }\n\n                // Add emoji and return result\n                const categoryEmojis = {\n                    \"Healthy\": \"ü•ó\",\n                    \"Fast\": \"üçî\",\n                    \"Asian\": \"üçú\",\n                    \"Italian\": \"üçù\",\n                    \"Mexican\": \"üåÆ\",\n                    \"Dessert\": \"üç∞\",\n                    \"Breakfast\": \"üç≥\",\n                    \"Vegetarian\": \"ü•¨\",\n                    \"Seafood\": \"ü¶ê\",\n                    \"Comfort\": \"üç≤\"\n                };\n\n                const emoji = categoryEmojis[category] || \"üçΩÔ∏è\";\n                const finalSuggestion = `${suggestion} ${emoji}`;\n                console.log('Final Suggestion with Emoji:', finalSuggestion);\n                return finalSuggestion;\n\n            } catch (error) {\n                if (retries === maxRetries - 1) {\n                    console.error('Error getting meal suggestion:', error);\n                    return getFallbackSuggestion(category);\n                }\n                retries++;\n                await new Promise(resolve => setTimeout(resolve, 2000));\n            }\n        }\n        \n        return getFallbackSuggestion(category);\n    }\n\n    // Use the imported fallback meals\n    function getFallbackSuggestion(category) {\n        const options = _fallbackMeals_js__WEBPACK_IMPORTED_MODULE_0__.fallbackMeals[category] || [`${category} Special üçΩÔ∏è`];\n        return options[Math.floor(Math.random() * options.length)];\n    }\n\n    decideMealBtn.addEventListener('click', async function() {\n        if (!categorySelect.value) return;\n        decideMealBtn.disabled = true;\n        \n        try {\n            const suggestion = await getMealSuggestion(currentCategory);\n            currentMeal = suggestion;\n            mealResult.innerHTML = `\n                <p class=\"fs-2 fw-bold text-primary mb-0\">${suggestion}</p>\n            `;\n            uploadSection.classList.remove('d-none');\n        } catch (error) {\n            console.error('Suggestion error:', error);\n            mealResult.innerHTML = '<p class=\"text-danger\">Error getting meal suggestion. Please try again.</p>';\n        } finally {\n            decideMealBtn.disabled = false;\n        }\n    });\n\n    // Handle image preview\n    document.getElementById('mealImage').addEventListener('change', function(e) {\n        if (this.files && this.files[0]) {\n            const reader = new FileReader();\n            reader.onload = function(e) {\n                imagePreview.src = e.target.result;\n                imagePreview.classList.remove('d-none');\n            }\n            reader.readAsDataURL(this.files[0]);\n        }\n    });\n\n    async function classifyImage(imageFile, maxRetries = 5) {\n        const reader = new FileReader();\n        return new Promise((resolve, reject) => {\n            reader.onload = async function() {\n                const base64Data = reader.result.split(',')[1];\n                \n                let retries = 0;\n                while (retries < maxRetries) {\n                    try {\n                        const response = await fetch(\n                            \"https://api-inference.huggingface.co/models/nateraw/food\",\n                            {\n                                headers: { \n                                    'Authorization': `Bearer ${HF_ACCESS_TOKEN}`,\n                                    'Content-Type': 'application/json'\n                                },\n                                method: \"POST\",\n                                body: JSON.stringify({ inputs: base64Data })\n                            }\n                        );\n                        const result = await response.json();\n                        console.log('Raw API response:', result); // Debug log\n                        \n                        if (result.error && result.error.includes('loading')) {\n                            // Model is loading, wait and retry\n                            retries++;\n                            console.log(`Model loading, attempt ${retries} of ${maxRetries}...`);\n                            await new Promise(resolve => setTimeout(resolve, 2000)); // Wait 2 seconds\n                            continue;\n                        }\n                        \n                        // Handle different response formats\n                        if (Array.isArray(result)) {\n                            resolve(result);\n                            return;\n                        } else if (result.error) {\n                            console.error('API Error:', result.error);\n                            reject(new Error(result.error));\n                            return;\n                        } else {\n                            resolve([result]); // Wrap single result in array\n                            return;\n                        }\n                    } catch (error) {\n                        if (retries === maxRetries - 1) {\n                            reject(error);\n                            return;\n                        }\n                        retries++;\n                        await new Promise(resolve => setTimeout(resolve, 2000));\n                    }\n                }\n                reject(new Error('Max retries reached while waiting for model to load'));\n            };\n            reader.onerror = reject;\n            reader.readAsDataURL(imageFile);\n        });\n    }\n\n    async function checkMealMatch(suggestedMeal, detectedFood) {\n        try {\n            const prompt = `Compare: \"${suggestedMeal}\" and \"${detectedFood}\". Are they the same dish? Answer: [yes/no]`;\n            console.log('Meal Match Prompt:', prompt);\n\n            const response = await fetch(\n                \"https://api-inference.huggingface.co/models/facebook/bart-large\",\n                {\n                    headers: {\n                        \"Authorization\": `Bearer ${HF_ACCESS_TOKEN}`,\n                        \"Content-Type\": \"application/json\"\n                    },\n                    method: \"POST\",\n                    body: JSON.stringify({\n                        inputs: prompt,\n                        parameters: {\n                            max_length: 5,\n                            min_length: 2,\n                            temperature: 0.2,\n                            top_p: 0.9,\n                            do_sample: true,\n                            return_full_text: false\n                        }\n                    })\n                }\n            );\n\n            const result = await response.json();\n            console.log('Meal Match Raw Response:', result);\n            \n            if (result.error) {\n                throw new Error(result.error);\n            }\n\n            let answer = Array.isArray(result) ? result[0].generated_text : result.generated_text;\n            answer = answer.trim().toLowerCase();\n            \n            console.log('Cleaned Answer:', answer);\n            return answer.includes('yes') || answer.includes('true');\n\n        } catch (error) {\n            console.error('Error checking meal match:', error);\n            \n            // Fallback to simple text comparison if API fails\n            const simplifiedSuggested = suggestedMeal.toLowerCase();\n            const simplifiedDetected = detectedFood.toLowerCase();\n            \n            // More lenient matching logic\n            const suggestedWords = simplifiedSuggested.split(' ');\n            const detectedWords = simplifiedDetected.split(' ');\n            \n            // Check if any word from either phrase matches\n            const hasMatch = suggestedWords.some(sword => \n                detectedWords.some(dword => \n                    sword.includes(dword) || dword.includes(sword)\n                )\n            );\n\n            // Special cases for common variations\n            const commonVariations = {\n                'burger': ['hamburger', 'cheeseburger'],\n                'sushi': ['maki', 'roll', 'nigiri'],\n                'pasta': ['spaghetti', 'noodle', 'macaroni'],\n                'rice': ['risotto', 'pilaf'],\n                'chicken': ['poultry', 'hen'],\n                'fish': ['salmon', 'tuna', 'cod']\n            };\n\n            // Check common variations\n            for (const [base, variations] of Object.entries(commonVariations)) {\n                if ((simplifiedSuggested.includes(base) && \n                     variations.some(v => simplifiedDetected.includes(v))) ||\n                    (simplifiedDetected.includes(base) && \n                     variations.some(v => simplifiedSuggested.includes(v)))) {\n                    return true;\n                }\n            }\n\n            return hasMatch;\n        }\n    }\n\n    // Update the form submission handler\n    uploadForm.addEventListener('submit', async function(e) {\n        e.preventDefault();\n        \n        const imageFile = document.getElementById('mealImage').files[0];\n        if (!imageFile) return;\n\n        try {\n            uploadFeedback.classList.remove('d-none', 'alert-success', 'alert-danger');\n            uploadFeedback.classList.add('alert-info');\n            uploadFeedback.textContent = 'Analyzing your image... This might take a few seconds.';\n\n            // Get food classification\n            const predictions = await classifyImage(imageFile);\n            console.log('Food detection:', predictions);\n            \n            // Get the top detected food\n            const detectedFood = predictions[0].label;\n            console.log('Detected food:', detectedFood);\n            \n            // Remove emoji from currentMeal\n            const suggestedMeal = currentMeal.replace(/[\\u{1F300}-\\u{1F6FF}]/gu, '').trim();\n            console.log('Suggested meal:', suggestedMeal);\n\n            // Check if they match using LLM\n            const isMatch = await checkMealMatch(suggestedMeal, detectedFood);\n            console.log('Is match?', isMatch);\n\n            // Show appropriate feedback\n            uploadFeedback.classList.remove('alert-info');\n            if (isMatch) {\n                uploadFeedback.classList.add('alert-success');\n                uploadFeedback.innerHTML = 'üéâ Correct meal! You earned 10 points! üåü';\n            } else {\n                uploadFeedback.classList.add('alert-danger');\n                uploadFeedback.innerHTML = `‚ùå This doesn't look like ${suggestedMeal}.<br>\n                                          Detected: ${detectedFood}`;\n            }\n\n            // Reset form after 5 seconds\n            setTimeout(() => {\n                uploadForm.reset();\n                imagePreview.classList.add('d-none');\n                uploadFeedback.classList.add('d-none');\n            }, 5000);\n\n        } catch (error) {\n            console.error('Classification error:', error);\n            uploadFeedback.classList.remove('alert-info');\n            uploadFeedback.classList.add('alert-danger');\n            uploadFeedback.textContent = 'Error analyzing image. Please try again.';\n        }\n    });\n}); \n\n//# sourceURL=webpack:///./script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./script.js");
/******/ 	
/******/ })()
;